<?xml version="1.0"?>
<article>
  <artheader>
    <date>2003-04-14</date>
    <title>Reference and Collection Proxies</title>
    <authorgroup>
      <author>
        <firstname>Mark</firstname>
        <surname>Woodbridge</surname>
      </author>
    </authorgroup>
  </artheader>
  
  <sect1>
    <title>Overview</title>
    <para>This document explains how proxies for reference and collection fields of business objects are created and materialised.</para>
    <para>In this context a proxy is an object that represents a database object, or a collection of such objects, and effectively delays database access by only performing a query to retrieve a field of an object or an element of a collection when it is requested. The discussion is split between consideration of proxies for fields that are references to objects and those that are collections of objects.</para>
  </sect1>
  
  <sect1>
    <title>Reference Proxies</title>
      <para>A reference proxy is a dummy object that implements an arbitrary number of interfaces. Any calls to methods specified in these interfaces are actually handled by an interceptor object which can choose to pass them to an object that implements the relevant method, or can return values directly to the caller. No calls are actually invoked on the proxy object - even after materialisation its fields remain null. Specifically, <command>Gene.getName() != Gene.name == null</command></para>
      <para>Such Proxies for objects in our data model appear to implement two interfaces: of the object they are representing (eg. <function>setName</function>, <function>equals</function>) and of the LazyReference interface (<function>isMaterialised</function>, <function>setObjectStore</function>). We use the cglib coge generation library to construct reference proxies - this allows dynamic generation for classes, whereas <filename>java.lang.proxy</filename> only allows it for interfaces. This means that don't require artificial code like "class GeneImpl implements Gene", where the Gene interface would only be necessary for proxy generation (it explicitly specifies the methods to be intercepted).</para>
      <para>The real object that the proxy represents is retrieved using a <classname>objectStore</classname> <classname>classConstraint</classname>/<classname>QueryObjectReference</classname> query (provided at proxy construction) and stored as a field of the interceptor so that future requests do not require database access. To execute the objectstore query the interceptor must have a reference to an objectstore - this is set in a just-in-time fashion by the <function>Results.next()</function> method, which checks whether <classname>LazyReference</classname>s exist as fields of objects in the next <classname>ResultsRow</classname> and sets the objectstore to be the same as that of the <classname>Results</classname> object.</para>
      <para>Special consideration of equality is required. We have specified that for two objects to be equal their internal identifiers must be equal, unless both are zero, in which case a primary key comparison is performed. Proxies always have an id (again, provided at construction) so <command>.equals</command> and <command>.hashCode</command> methods need not require materialisation, and the <command>.equals</command> method for the actual class is not invoked. Any other business object method (bean property getters and setters) are passed through to the materialised object.</para>
      <para>Note that the <command>.equals</command> comparison between proxy and non-proxy is asymmetric. calling <command>&lt;gene-proxy&gt;.equals()</command> will not invoke Gene.equals, but will rather perform a numeric id equality test in the interceptor. <command>&lt;gene&gt;.equals()</command> will use <function>Gene.equals()</function>, which first checks whether the comparison object has an id set. It is not sufficient to use "that.id.equals(id)" because "that.id" is always "null" - the proxy is a dummy object for method interception. so <function>Gene.equals()</function> must use <function>Gene.getId()</function>.</para>
  </sect1>
  <sect1>
    <title>Collection Proxies</title>
      <para>Collection proxies are simply <classname>(Singleton)Results</classname> objects containing a specific <classname>Query</classname>. There is no dynamic code generation required in this case. Such collections are materialised page-by-page as required during iteration. Whereas reference proxies are actually given to the client in the form of objects implementing <classname>LazyReference</classname> (though these don't appear as <classname>ResultRow</classname> elements) the <classname>LazyCollection</classname> interface is never exposed - collection fields set to be lazy are in the <classname>PersistenceBroker</classname> are replaced with <classname>SingletonResults</classname> objects during <classname>ResultRow</classname> creation. For an arbitrary field to set to be an object implementing LazyCollection, the LazyCollection interface must implement the <classname>Set</classname> and <classname>List</classname> interfaces.  However, this isn't true (at present) for the <classname>SingletonResults</classname> object (which is a <classname>List</classname>).</para>
  </sect1>

  <sect1>
    <title>Implementation</title>
    <para>The actual materialisation process for the objects in a ResultsRow proceeds as follows. </para>
    
    <para>
      For object references:
      <programlisting>
        MultiObjectRsIterator.next()
        -> RsIterator.getObjectFromResultSet()
        -> PersistenceBroker.retrieveReferences()
        -> PersistenceBroker.retrieveReference()
        -> PersistenceBrokerFlyMine.getReferencedObject()
      </programlisting>
    </para>
      
      <para>If the metadata indicates that this object reference is lazy then a proxy is built from the type of the referenced object combined with the interface (LazyReference) that allows setting of the objectstore. The proxy is passed a query and id for the object it is representing (see <function>getReferencedObject</function> for more details).</para>
    
    <para>
      For collection references:
      <programlisting>
        -> MultiObjectRsIterator.next()
        -> RsIterator.getObjectFromResultSet()
        -> PersistenceBroker.retrieveCollections()
        -> PersistenceBrokerFlyMine.retrieveCollection()
      </programlisting>
    </para> 
    
    <para>If the metadata indicated that this collection reference is lazy then set the collection field to be a new lazy collection built using a classConstraint/queryObjectReference query (see <function>retrieveCollection</function> for more details).</para>
    
    <para>The classes involved in implementing proxies are:
      <itemizedlist>
        <listitem><classname>LazyReference</classname> and <classname>LazyCollection</classname> (interfaces by <classname>Results</classname> to distinguish lazy object and collection references)</listitem>
        <listitem><classname>LazyInitializer</classname> (the interceptor for <classname>LazyReference</classname> proxy objects)</listitem>
        <listitem><classname>PersistenceBrokerFlyMineImpl</classname> (which sets fields to be proxies where necessary)</listitem>
        <listitem><classname>Results</classname> (which set the ObjectStores of reference proxies so that materialisation queries can be run, and replaces collection queries with <classname>SingletonResults</classname>)</listitem>
      </itemizedlist>
    </para>

    <para>Note that an alternative method for delaying queries would be to make everything a proxy. This could be a more elegant approach (though at odds with the approach favoured by Hibernate and OJB.) This involves intercepting all attempts to access fields of an object, and at that time running a query for the field. This means that every object has access to an object store, along with ids (or queries) for each of its references. Such an implementation would work above any ObjectStore implementation. To illustrate this approach, consider a query for an Employee. In this case, an Employee object is an element in the ResultsRow. Using the current method, the Employee is a real object, whereas Employee.getDepartment() returns a proxy. No database access to materialise the department is made until an attempt is made a access one of its fields. Using the new method, Employee would be a proxy, and a database access would be made on a call to Employee.getDepartment().</para>

    <para>Note also that, at present, the LazyInitializer has both the id and a query for its real subject. The id is not strictly necessary, but allows the avoidance of early materialisation. Notice that an ObjectStore.getById method would make the query redundant, and avoid the overhead of parsing the query.</para>
  </sect1>
</article>


