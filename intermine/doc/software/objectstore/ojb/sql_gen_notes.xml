<?xml version="1.0"?>

<article>

<artheader>
<date>2003-02-20</date>
<title>Notes on Generating SQL from OJB</title>
<authorgroup>
<author>
<firstname>Matthew</firstname>
<surname>Wakeling</surname>
</author>
<author>
<firstname>Richard</firstname>
<lastname>Smith</lastname>
</author>
</authorgroup>
</artheader>

  <sect1>
    <title>Inputs to SQL generation module</title>
    <itemizedlist>
      <listitem>a FlyMine Query object (<classname>org.flymine.objectstore.query.Query</classname>)</listitem>
      <listitem>an array of <classname>ClassDescriptor</classname> objects:
	<itemizedlist>
          <listitem><classname>FieldDescriptor[]</classname></listitem>
          <listitem><classname>ObjectReferenceDescriptor[]</classname></listitem>
          <listitem><classname>CollectionDescriptor[]</classname></listitem>
	</itemizedlist>
      </listitem>
      <listitem>LIMIT and OFFSET values</listitem>
    </itemizedlist>
  </sect1>
  
  <sect1>
    <title>Outputs from the SQL generation module</title>
    <itemizedlist>
      <listitem>An SQL String, including the following elements:
        <itemizedlist>
          <listitem>List of tables or other data sources to form the FROM list section of the SQL statement.
            <itemizedlist>
              <listitem>Make up aliases for each table, and then refer to each table as that alias in the rest of the query.</listitem>
              <listitem>FROM clause can include subqueries, in the case that there is more than one aggregation (possibly other cases as well).</listitem>
              <listitem>Work out if we need to do any outer joins. Probably, we will just do most of the query inside a subquery (which can be optimised), and then left outer join that with other stuff if necessary.</listitem>
            </itemizedlist>
          </listitem>
          <listitem>List of fields in the SELECT list of the query, in the order that the RowReader is going to expect them.
            <itemizedlist>
              <listitem>Each field must be aliased, so that it doesn't clash with field names from other tables, especially other identical tables.</listitem>
              <listitem>Need to ask the Query object what order and aliases each field is, and the RowReader should refer to the same Query.</listitem>
              <listitem>SELECT list may contain:
                <itemizedlist>
                  <listitem>Entire classes (where one includes all its members). These may contain:
                    <itemizedlist>
                      <listitem>Normal fields</listitem>
                      <listitem>Collections - <emphasis>where we must decide whether to be lazy about loading them, at which point we need to fill the authority with information on how to do this, for the RowReader to use, or we load them explicitly, at which point we need to do a LEFT OUTER JOIN.</emphasis>
                        Actually, this is all wrong - the RowReader sorts it all out for itself, and never accepts data from a LEFT OUTER JOIN, unlike Hibernate.
                        So we don't need to worry about this.
                      </listitem>
                      <listitem>Object references - very similar to Collections.</listitem>
                    </itemizedlist>
                  </listitem>
                  <listitem>Aggregate functions (aliases to something). In this case, the RowReader needs to refer to the authority mentioned above to work out exactly what the aggregate is, so it can create a collated result with a collection of all the objects that are counted in the aggregate. This collection would be a normal Query, which may return more than one column, in ResultRow objects.</listitem>
                  <listitem>Individual fields.
                    We may include a restriction that these can only be present if the query is distinct, or we may not - TBA.
                    This would return a collated result, like an Aggregate does.</listitem>
                  <listitem>Expressions - this also would return a collated result.
                    However, there are the cases where the result does not refer to a single object, where the collated result would not contain a collection of objects that match the result, so a non-collated result is produced instead.
                    An example is "10 - 5", which refers to no object.
                    The Expression "A.x - B.y", which refers to two different objects would return a collated result with a query that returns two columns.</listitem>
                  <listitem>QueryValue - this returns a non-collated result.</listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>WHERE clause, including:
            <itemizedlist>
              <listitem>All the normal constraints that are explicitly in the Query object. Some constraints must be translated:
                <itemizedlist>
                  <listitem>Constraints that reference objects, rather than fields.</listitem>
                  <listitem>Constraints that reference Collections, whether they are one-to-many collections that merely require a foreign key replacement, or whether they require an intermediate table.</listitem>
                  <listitem>Subquery constraints constraining an object to be in a Query - need to translate object to unique key field.</listitem>
                </itemizedlist>
              </listitem>
              <listitem>A constraint to join on any LEFT OUTER JOINs.</listitem>
            </itemizedlist>
          </listitem>
          <listitem>GROUP BY clause.</listitem>
          <listitem>ORDER BY clause.</listitem>
          <listitem>LIMIT and OFFSET clauses, from separate information.</listitem>
        </itemizedlist>
      </listitem>
      <listitem>An object which records information about the columns being returned by the database, and how the RowReader should materialise them into objects. In retrospect, it looks like the Query object itself will be this object. The RowReader needs to be carefully inspected, so we can make sure it reads the correct aliased fields. Also need to be careful about whether or not the RowReader might expect fields for a linked object created by LEFT OUTER JOINS, when we have decided not to actually do a LEFT OUTER JOIN.</listitem>
      <listitem>Check the incoming Query object, and reject it if there are any of the following errors:
        <itemizedlist>
          <listitem>Every class in the Query must exist as a ClassDescriptor in OJB.</listitem>
          <listitem>Every field reference in the entire Query (SELECT list, constraints, group by, etc.) must exist as a FieldDescriptor, ObjectReferenceDescriptor, or CollectionDescriptor in OJB, specifically referring to a ClassDescriptor in OJB.</listitem>
          <listitem>Every field reference in the entire Query must be a member of one of the classes in the FROM list of the Query.</listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>concerns/complications</title>
    <itemizedlist>
      <listitem>multi-mapped tables</listitem>
      <itemizedlist>
        <listitem>refers to mapping of subclasses to a single table (see below)</listitem>
      </itemizedlist>
      <listitem>what to do about left outer joins?  whether we should produce them (used in cascaded loading)
        They are currently used (in a very dodgy way) for multiple extents when searching a superclass.
        This almost makes sense for the case where you are searching for a single row (or the existence of a row) in the superclass, but seems to break quite a lot of other stuff.
        OJB used to do such a query by performing several queries - one for each subclass table.
        We will not need to use LEFT OUTER JOINs as long as all superclasses are implemented as a single table.
        We will not have to do multiple queries either.
      </listitem>
      <listitem>aliases for tables/fields in select [Query.getAliases()]
        <itemizedlist>
          <listitem>Query has standard alias generator for table aliases. We should use it as the authority on table aliases.</listitem>
          <listitem>FieldDescriptor has a getColumnName() method to get the column name.</listitem>
          <listitem>Our SQL query should return column names in the form of "table alias""column name", which is sufficient to make every column in the output uniquely named.</listitem>
          <listitem>The RowReader will then be passed some information created in the same way in order to read these aliases.</listitem>
        </itemizedlist>
      </listitem>
      <listitem>how will RowReader read cope with aliased column names
        The RSIterator creates fabricated ResultSet objects with normal field names of just the object being materialised, and hands it to the RowReader.
      </listitem>
      <listitem>understand extents and deal with them
        <itemizedlist>
          <listitem>Extents represent subclasses of data classes in the object model.
            If a data object in the database has several subclasses, then there are several possible methods of mapping these objects onto database tables:
            <itemizedlist>
              <listitem>One table per objectclass.
                For this method, a search of a particular leaf objectclass (probably quite frequent) will happen quite quickly, because the database only deals with a small table detailing the data for that particular object class.
                However, if one needs to search all the objects of the super class, then it will involve running several queries, and joining their results together with a UNION operation (slow).</listitem>
              <listitem>One table for all subclasses.
                For this method, a search of a particular leaf objectclass will be slower, because the database has to filter through all the objects that are not this object class.
                However, an optimiser will separate out those objects into a separate table anyway, effectively giving the speed of the first method.
                A search of all the objects of a superclass will be simple (and relatively fast).</listitem>
              <listitem>One table for superclass fields, and other tables for extra fields of subclasses.
                OJB does not support this method, and it seems to combine the shortcomings of both of the previous methods.</listitem>
            </itemizedlist>
            It is probably simplest to implement method two - this involves no UNIONS, which the current optimiser cannot handle, and would involve more complex code.
            However, in the future it is probably best to finish the code off, to make it more acceptable to outside users.</listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </sect1>
  
</article>

