<?xml version="1.0"?>

<article>

	<artheader>
		<date>2003-08-01</date>
		<title>Flymine - Fetching related objects in the Results object</title>
		<authorgroup>
			<author>
				<firstname>Matthew</firstname>
				<surname>Wakeling</surname>
			</author>
		</authorgroup>
	</artheader>

	<sect1>
		<title>Introduction</title>
		<para>This document is a proposal for a performance improvement to the org.flymine.objectstore.query.Results object.
			The proposal is intended to alleviate a problem inherent in an object-based database - that is that following references from objects will result in a request to the database to fetch the data.
			Each of these database requests is small, and returns a tiny amount of data for a large amount of work spent.
			If many of these operations are performed, the efficiency of the database system is greatly reduced.
			This proposal attempts to alter the behaviour of the objectstore, so that it attempts to load this data using more efficient, larger queries.</para>
	</sect1>

	<sect1>
		<title>Why is this needed?</title>
		<para>Consider the situation where a database has two object classes - A and B.
			Objects of type A each have a reference to an object of type B.
			The user writes a program that generates a query for all objects of type A, and iterates through the entire Results object, calling toString on each object.
			Unfortunately, the toString method of class A uses the reference to the object of type B.
			Therefore, the program performs lots of single object fetches of objects of type B.</para>
		<para>Even if the user's program generates a query that explicitly returns objects of type A alongside their associated objects of type B, those B objects will be held in the batch cache of the Results object, and the references to them from the A objects will not be filled in.
			Therefore, the B objects would be fetched as above.</para>
	</sect1>

	<sect1>
		<title>First modification</title>
		<para>The first modification proposed is to extend the getObjectByExample cache of the ObjectStore, so that it indexes on class and ID, as well as primary keys.
			Then, all objects loaded by whatever means would be added to this cache.
			The objectstore would also need to provide a getObjectById method, which the object reference proxy would use to access the referred object.</para>
		<para>This would provide a performance improvement IF the user's program generates a query that gets the two objects alongside.
			This way, the sub-objects will be brought into memory with the main objects, using the same batching and prefetch mechanism as the main objects.</para>
		<para>This modification would not be too disruptive to the codebase, and would not be very difficult.</para>
	</sect1>

	<sect1>
		<title>Second modification</title>
		<para>The second modification is for the system to automatically alter the query that is being run, so that it accesses the sub-objects along with the main objects.
			The first modification can then provide the performance improvement.
			This could be a little tricky to implement.
			It would need a method of telling whether or not the original query does bring in such objects, and also whether such objects are actually required.
			It needs to make use of a LEFT OUTER JOIN, in order to guarantee that the number of rows in the results does not change.</para>
	</sect1>
</article>

