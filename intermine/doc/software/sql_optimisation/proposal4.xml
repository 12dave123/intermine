<?xml version="1.0"?>

<article>

	<artheader>
		<date>2003-07-03</date>
		<title>InterMine - A proposal to improve the Query Optimiser to scale well for many precomputed tables</title>
		<authorgroup>
			<author>
				<firstname>Matthew</firstname>
				<surname>Wakeling</surname>
			</author>
		</authorgroup>
	</artheader>

	<sect1>
		<title>Introduction</title>
		<para>This document describes a proposal to improve the Query Optimiser, so that it scales well for many precomputed tables.</para>
	</sect1>

	<sect1>
		<title>Rationale</title>
		<para>Currently, the first stage the optimiser performs is to take the entire set of PrecomputedTable objects, and attempt to fit every single one into the query.
			This takes linear time for the number of PrecomputedTable objects, which may be prohibitive in the future when there are many PrecomputedTable objects.
			Indexing precomputed tables to avoid searching through every single precomputed table is tricky, because the criteria that permits a precomputed table to fit into a query includes that it does not contain any other tables than those in the query.
			However, the PrecomputedTableManager could have an index (based on a Map) from table name to all precomputed tables that contain that table.</para>
	</sect1>

	<sect1>
		<title>Implementation</title>
		<para>When the optimiser requests a set of precomputed tables, it could supply a set of table names.
			The PrecomputedTableManager could then look up each of those table names, create the union set of all the results, and pass that back.
			That union set could then be stored away so that it can be accessed again without generating the union.
			This would reduce the number of precomputed tables that the optimiser has to check through.
			It will provide a greater benefit the more database tables there are, since it will then produce a lesser proportion of the total number of precomputed tables.</para>
	</sect1>
</article>
			
