<?xml version="1.0"?>

<article>

<artheader>
	<date>2002-12-2</date>
	<title>Flymine - SQL Query Optimsation</title>
	<authorgroup>
		<author>
			<firstname>Matthew</firstname>
			<surname>Wakeling</surname>
		</author>
	</authorgroup>
</artheader>

<sect1>
<title>Meta-data in the database</title>
<para>
	We are going to need to store data in the database regarding what precomputed join tables are available, and what form they take.
	Each precomputed table will contain data produced by joining a certain set of tables together (note that a given table can be specified more than once), restricted by a certain set of restrictions, and ordered in a certain way.
	Therefore, we need to be able to ask the database to return all rows of table, where each row represents a precomputed join table, where none of the precomputed join tables have any tables that are not present in our list created from the query (again, noting that any table can be specified more than once, and it should be able to reorder duplicate tables to get a good match), and none of the precomputed join tables have any restrictions that are not present in our list of restrictions created from the query.
	We also need this query to return very quickly, otherwise there is no point in doing it.
</para>

<para>
	Therefore, the following database layout should be used:
	<itemizedlist>
		<listitem>TABLE: join_list. Precomputed joins.
			Each row represents a precomputed join table.
			<itemizedlist>
				<listitem>FIELD: name. table name.
					This is the name of the table that the entry points to.</listitem>
				<listitem>FIELD: selectstatement. full select statement used to create the precomputed table</listitem>
			</itemizedlist></listitem>
		<listitem>TABLE: tables contained in precomputed joins.
			Each row represents a table included in a precomputed join table.
			<itemizedlist>
				<listitem>FIELD: precomputed table name.
					This is the name of the precomputed join table, so the same name as the field in the previous table.
					These objects link to the above table through this field.</listitem>
				<listitem>FIELD: table name.
					This is the name of the table included in the precomputed join table.</listitem>
			</itemizedlist></listitem>
		<listitem>TABLE: restrictions contained in precomputed joins.
			Each row represents a restriction included in a precomputed join table.
			A particular precomputed join table may have more than one of these, in which case they act as if they are ANDed together.
			<itemizedlist>
				<listitem>FIELD: precomputed table name.
					This is the name of the precomputed join table.
					These objects link to the first table through this field.</listitem>
				<listitem>FIELD: text of restriction.
					This is in the form of the original (non-precomputed) table field names, rather than the field names of the precomputed tables.</listitem>
			</itemizedlist></listitem>
	</itemizedlist>
	A SQL query like 
	<emphasis>select fa.name from (select f.name from (select join_list.name, joined_restrict.restriction from join_list left join joined_restrict on joined_restrict.restriction not in (</emphasis>list of restrictions<emphasis>) and join_list.name = joined_restrict.join_name) as f where f.restriction is null) as fa, (select f.name from (select join_list.name, joined_tables.table_name from join_list left join joined_tables on joined_tables.table_name not in (</emphasis>list of tables<emphasis>) and join_list.name = joined_tables.join_name) as f where f.table_name is null) as fb where fa.name = fb.name;</emphasis>
	would extract a list of suitable precomputed tables from the database.
	The query searches for all precomputed joins that do not contain any tables or restrictions other than those in the query we wish to optimise.
</para>

<para>
	This search will give us a list of precomputed tables.
	We can then load in all the information on those precomputed tables into memory.
	The optimiser can then go through all the possible selections of these precomputed tables.
	For each selection, no two precomputed tables should refer to the same table in the query we wish to optimise.
	The optimiser can then produce a list of selections of precomputed tables that do not clash with each other.
	For each of these selections, the optimiser can reconstruct the query we wish to optimise, replacing tables with the precomputed tables, and removing restrictions that are already encoded in the precomputed tables.
	For each of these reconstructed queries, the optimiser can then ask the database to estimate how long each would take to execute.
	The optimiser can then easily pick the fastest reconstructed query.
</para>

<para>
	In addition, to perform optimisation of a query where there are multiple copies of the same table, the optimiser produces a list of mappings, which reorder the copies of a tables in all possible combinations (up to three copies of each table) - one of the mappings is the null mapping.
	From this, it produces a list of all the mappings from symbolic precomputed table copy names to the combination of a mapping described in the previous sentence and a normal precomputed table.
	Each symbolic precomputed table copy can rewrite a certain set of original query tables, determined by the set of tables that the original precomputed table rewrites, and the mapping that reorders the original query table copies.
	These symbolic precomputed table copies are then applied to the original query as in the previous paragraph, replacing "precomputed table" with "symbolic precomputed table copy".
</para>

<para>
	While producing the list of symbolic precomputed table copies, the optimiser attempts to exclude copies that perform a translation identical to one that a previous symbolic precomputed table copy performs.
	The optimiser performs a database query to retrieve a list of precomputed tables (to be converted into symbolic precomputed table copies) for each query table copy reordering mapping.
	The null mapping produces a SQL query like that described a few paragraphs earlier, which returns all precomputed tables that will help with the null mapping.
	Subsequent mappings produce SQL queries that have extra conditions attached, to try to exclude precomputed tables that would be converted into symbolic precomputed table copies that perform a translation that a previous one does.
	The following list describes what conditions are imposed for a particular query table that has more than one copy, ignoring other query tables with more than one copy.
	In fact, the optimiser does all the possible combinations, and combines the extra conditions with the AND operator.
	<itemizedlist>
		<listitem>With the null mapping (for this query table only of course), no extra conditions are added.
			This covers all symbolic precomputed table copies where the mapping between copies is null.</listitem>
		<listitem>With the mapping that swaps the first two tables (which is used when there are two or more copies of the query table), the condition should be that the precomputed table references the first or second copy of the table (or both).
			All other precomputed tables are not actually altered by the mapping, therefore their symbolic precomputed table copies would be duplicates of ones created by the null mapping.</listitem>
		<listitem>The third mapping is that which swaps the first and third copies of a query table.
			The condition should be that the precomputed table references the first or third copy of the table (or both).
			This is because neither the first or third copies have yet been mapped in this way.</listitem>
		<listitem>The fourth mapping is that which swaps the second and third copies copies of a query table.
			As neither of these have been mapped in this way, the condition is that the precomputed table references the second or third copy of the table (or both).</listitem>
		<listitem>The fifth mapping is that which maps the first copy to the second copy, the second copy to the third, and the third to the first.
			Now, each of these mappings has happened before, but never more than one at a time.
			Therefore, the condition should be that the precomputed table references at least two of copies one, two, and three.</listitem>
		<listitem>The sixth mapping is the reverse of the fifth mapping, and as such should have the same conditions.</listitem>
	</itemizedlist>
</para>
</sect1>
</article>

