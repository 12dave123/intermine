<?xml version="1.0"?>

<article>

	<artheader>
		<date>2003-07-03</date>
		<title>InterMine - A proposal to improve the Query Optimiser for requests with non-zero offsets</title>
		<authorgroup>
			<author>
				<firstname>Matthew</firstname>
				<surname>Wakeling</surname>
			</author>
		</authorgroup>
	</artheader>

	<sect1>
		<title>Introduction</title>
		<para>This document describes a proposal to improve the Query Optimiser, specifically speeding up queries that have a non-zero OFFSET.</para>
	</sect1>

	<sect1>
		<title>Rationale</title>
		<para>At the moment, the InterMine performs paging of results sets, by running queries in the database with an OFFSET according to the page requested.
			PostgreSQL must produce the entire results set up to the end of data required, and <highlights>count</highlights> OFFSET rows to throw away before returning useful data.
			This operation has a time complexity of O(OFFSET), therefore the operation of paging straight through a large results set has a time complexity of O(square of rows).
			However, it should be possible to perform a page request in constant time complexity, and therefore page straight through the results set in time complexity O(rows).</para>
	</sect1>

	<sect1>
		<title>Algorithm</title>
		<para>We can take advantage of the fact that the results set is always ordered, and the optimiser knows the order key field.
			The optimiser must have access to the results from the database.
			The optimiser can record offsets where the order key field value changes, and therefore build up a set of shortcuts for getting to various parts of the results set.
			Then, when a query is run with a non-zero offset, it can be altered with an extra condition using one of those recorded values that removes some proportion of the results rows before the beginning of the required range, and with an altered OFFSET to find the correct row.</para>
	</sect1>

	<sect1>
		<title>Implementation</title>
		<para>This feature would involve a little refactoring.
			The cleanest way to implement it would be for the optimiser to actually run the query and pass the results set back to the caller.
			Alternatively, the caller could run the query, use it, and pass the optimiser the results, though this would be less ideal.
			The optimiser needs to find the last change in the order by key field, and record the offset and value of the new value.
			When a query is made, these values are looked up, and the last value at or before the beginning of the required range is used to add an extra constraint to the query and alter the OFFSET.
			The OptimiserCache should store the optimised queries before this alteration is applied to them.</para>
	</sect1>
</article>

