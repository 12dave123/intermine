#!/usr/bin/perl


# CVS does not offer a way to rename a file in a way that CVS can
# track later.  See Section 4B for more information.
#
# Here is the best (to some, the only acceptable) way to get the
# effect of renaming, while preserving the change log:
#
# Copy the RCS (",v") file directly in the Repository.
#
#      cp $CVSROOT/[odir]/[ofile],v $CVSROOT/[ndir]/[nfile],v
#
# By duplicating the file, you will preserve the change
# history and the ability to retrieve earlier revisions of the
# old file via the "-r [tag/rev]" or "-D [date]" options to
# "checkout" and "update".
#
# Remove the old file using CVS.
#
#      cd [working-dir]/[odir]
#      rm [ofile]
#      cvs remove [ofile]
#      cvs commit [ofile]
#
# This will move the [ofile] to the Attic associated with [odir].
#
# Retrieve [nfile] and remove all the Tags from it.
#
# By stripping off all the old Tags, "checkout -r" and
# "update -r" won't retrieve revisions Tagged before
# the renaming.
#
#      cd [working-dir]/[ndir]
#      cvs update [nfile]
#      cvs log [nfile]                 # Save the list of Tags
#      cvs tag -d [tag1] [nfile]
#      cvs tag -d [tag2] [nfile]
#        .
#        .
#        .
#
# This technique can be used to rename files within one directory or
# across different directories.  You can apply this idea to
# directories too, as long as you apply the above to each file and
# don't delete the old directory.
#
# Of course, you have to change your build system (e.g. Makefile) in
# your [working-dir] to know about the name change.
#
# Warning: Stripping the old tags from the copied file will allow
# "-r [tag]" to do the right thing, but you will still have problems
# with "-D [date]" because there is no place to store the "deletion
# time".  See 5B.3 for more details.

use strict;

use File::Basename;
use Cwd;
use Env;
use Getopt::Std;

if ($#ARGV < 1) {
    die "Usage: $0 [options] <file1> [ <file2> [...] ] <destination>";
}

use vars qw($opt_d);
getopts('d') or die "getopts() failed!";

my ($file, $files);
my ($localdestination);
my ($localdestfile, $localdestdir, $localdestabsfile);
my ($localfile, $localdir, $localabsfile);

my ($serverfile, $serverdestination);

my $pwd = getcwd();

$localdestination = $ARGV[$#ARGV];
my @files = @ARGV[0..($#ARGV-1)];

if ((not -d $localdestination) && $#files > 0) {
    die "The destination must be a directory for multiple source files";
}

$localdestination = get_absolute($localdestination);
$serverdestination = get_server_equivalent($localdestination);

print "Moving @files to $localdestination\n";

if (not $opt_d) {
    print "You will lose any changes to original files - check them in before running cvsmove\n";
    print "Continue (y/N)\n";
    my $yn = <STDIN>;
    $yn =~ s/\n$//;

    exit unless ($yn =~ /[Yy]/);
}

foreach $file (@files) {

    chdir $pwd;

    if (not -f $file) {
	die "Cannot move $file - it is not a file";
    }

    $localabsfile = get_absolute($file);
    if (-d $localdestination) {
	$localdestabsfile = $localdestination."/".basename($localabsfile);
    }
    else {
	$localdestabsfile = $localdestination;
    }

    $localdir = dirname($localabsfile);
    $localfile = basename($localabsfile);
    $localdestdir = dirname($localdestabsfile);
    $localdestfile = basename($localdestabsfile);

    $serverfile = get_server_equivalent($localfile);


    # 1. Copy the archive file in the repository

    print "Copying $serverfile to $serverdestination\n";
    `scp $serverfile $serverdestination` unless $opt_d;

    # 2. Remove the old working file

#      cd [working-dir]/[odir]
#      rm [ofile]
#      cvs remove [ofile]
#      cvs commit [ofile]
    chdir $localdir;
    print "Deleting $localfile\n";
    unlink $localfile unless $opt_d;
    print "Doing \"cvs remove $localfile\"\n";
    `cvs remove $localfile` unless $opt_d;
    print "Doing \"cvs commit $localfile\"\n";
    `cvs commit -m \"Moving to $localdestfile\" $localfile` unless $opt_d;

    # 3. Grab the new file from the repository

    chdir $localdestdir;
    print "Doing \"cvs update $localdestfile\"\n";
    `cvs update $localdestfile` unless $opt_d;
    remove_tags($localdestfile) unless $opt_d;

}

sub remove_tags
{
    my ($file) = @_;
    my ($grab);
    my @tags;

    print "Removing tags from $file\n";
    open(LOG, "cvs log -h $file |") || return undef;

    $grab = 0;
    while (<LOG>) {
	if ($grab==1) {
            if (/keyword substitution:/) {
                $grab=0;
		next;
            }
	    /^\s(.+):/;
	    push @tags, $1;

	}
	if (/symbolic names:/) {
	    $grab=1;
	}
	
    }

    foreach (@tags) {
	print "Doing \"cvs tag -d $_ $file\"\n";
	`cvs tag -d $_ $file`;
    }
}


sub get_absolute
{
    my ($input) = @_;

    my $pwd = getcwd();

    if (not ($input =~ m/^\//)) {
	# Relative path
	$input = "$pwd/$input";
    }
    return $input;
}


sub get_server_equivalent
{
    my ( $input ) = @_;
    my ( $serverdir, $serverroot, $repos, $root, $cvsroot, $cvsserver );

    my ($dir, $filename);

    my $ending = ",v";

    if (-d $input) {
	$dir = $input;
    }
    else {
	$dir = dirname($input);
	$filename = basename($input);
    }

    $repos = "$dir/CVS/Repository";
    $root = "$dir/CVS/Root";

    open(REPOSITORY, "< $repos") || return undef;

    $serverdir = <REPOSITORY>;

    close REPOSITORY;

    chomp($serverdir);

    open(ROOT, "< $root") || return undef;

    $serverroot = <ROOT>;

    close ROOT;

    chomp($serverroot);

    if ($serverroot =~ m/^:ext:([a-z0-9\-\.]+):?(.*)/) {
	$cvsserver = $1;
	$cvsroot=$2;
    }
    else {
	$cvsroot = $CVSROOT;
    }


    if (defined $filename) {
	return $cvsserver.":".$cvsroot."/".$serverdir."/".$filename.$ending;
    }
    else {
	return $cvsserver.":".$cvsroot."/".$serverdir;
    }
}
