#!/usr/bin/perl

# This script will read a configuration file to decide the order in which
# to run a set of jobs. Dependencies are taken into account.

# The control file should look like the following:

##########################################################################################################################################################
#
# # No.	Days(0-6)	Depends	Logfile 			Keep	User	Machine	Command
# #	Sunday=0
#
# 1	1,2,3,4,5	-	$LOG/task1			7	flymine	mach1	$SCRIPTS/task1
#
# 2	1,2,3,4,5	1	$LOG/task2			7	flymine	mach1	$SCRIPTS/task2 -uflymine
# 3	1,2,3,4,5	2	$LOG/task3			7	flymine	mach1	$SCRIPTS/task3	
# 4	1,2,3,4,5	3	$LOG/task4			7	flymine	mach1	$SCRIPTS/task4
# 5	1,2,3,4,5	4	$LOG/task5			7	flymine	mach1	$SCRIPTS/task5
# 6	1,2,3,4,5	4	$LOG/task6			7	flymine	mach1	$SCRIPTS/task6
# 7	1,2,3,4,5	5,6	$LOG/task7			7	flymine	mach1	$SCRIPTS/task7
# 8	1,2,3,4,5	7	$LOG/task8			0	root	mach2	/software/noarch/local/bin/task8
# 9	1,2,3,4,5	8	$LOG/task9			7	root	mach2	/software/noarch/local/bin/task9
# 10	1,2,3,4,5	9	$LOG/task10			1	root	mach2	/software/noarch/local/bin/task10
# 11	1,2,3,4,5	8	$LOG/task11			7	flymine	mach1	$SCRIPTS/task11 command line parameters
#
##########################################################################################################################################################

use strict;

use POSIX;
use Env;

# No buffering
select(STDOUT); $|=1;
select(STDERR); $|=1;

if ($#ARGV != 0) {
    die "Usage: $0 <config file>\n";
}

my ($configfile) = @ARGV;

my (%jobs, $jobs_to_run, $job_id, $time);

&ReadConfigFile($configfile);

while (&JobsNotYetRun()) {
    $jobs_to_run = &FindJobsToRun();

    foreach (@$jobs_to_run) {
	&RunJob($_);
	$time = POSIX::strftime("%l:%M%p", localtime(time));
	print "$time: Running job $_ ($jobs{$_}->{'command'}) with PID $jobs{$_}->{'pid'}\n";
    }

    $job_id = &WaitForAnyJobToFinish();
    &RemoveJob($job_id);

}

#############################################################################

sub WaitForAnyJobToFinish() {

    while (1) {
	foreach (keys %jobs) {
	    if (($jobs{$_}->{'pid'} > 0) &&
		((waitpid $jobs{$_}->{'pid'}, &WNOHANG) > 0)) {
		# Job has finished
		print "Job $_ finished\n";
		return $_;
	    }
	}
	sleep 1;
    }
}

#############################################################################

sub RunJob() {
    my ($job) = @_;

    my ($pid, $logbase);

  FORK:
    # Fork and run the file
    if ($pid = fork) {
	# Parent
	$jobs{$_}->{'pid'} = $pid;
	return;
    }
    elsif (defined ($pid)) {
	system("(ssh -l $jobs{$_}->{'user'} $jobs{$_}->{'machine'} $jobs{$_}->{'command'})| logfile $jobs{$_}->{'logfile'} $jobs{$_}->{'log'}");
	exit;
    }
    elsif ($! =~ /No more process/) {
	# EAGAIN, supposedly recoverable fork error
	sleep 5;
	redo FORK;
    } else {
	die "Can't fork: $!\n";
    }
}

#############################################################################

sub JobsNotYetRun() {

    foreach (keys %jobs) {
	if ($jobs{$_}->{'pid'} == 0) {
	    return 1;
	}
    }
    return 0;
}

#############################################################################

sub FindJobsToRun() {
    my $ary_ref;

    foreach (keys %jobs) {
	if (($#{$jobs{$_}->{'depends'}} < 0) &&  # no elements
	    ($jobs{$_}->{'pid'} == 0)) { # not already running
	    push @$ary_ref, $_;
	}
    }

    return $ary_ref;
}

#############################################################################

sub RemoveJob {
    my ($job) = @_;
    my $depend;

    delete $jobs{$job}; # Remove from the jobs hash
    foreach (keys %jobs) {
	for $depend (0 .. $#{$jobs{$_}->{'depends'}}) {
	    if ($jobs{$_}->{'depends'}[$depend] == $job) {
		splice (@{$jobs{$_}->{'depends'}}, $depend, 1);
	    }
	}
    }
}

#############################################################################

sub ReadConfigFile() {
    # The config file has the following fields:
    # 0: Job number
    # 1: Days to run
    # 2: Dependencies
    # 3: Log file
    # 4: Log days
    # 5: User to run as
    # 6: Machine to run on
    # 7: Command to run

    my ($configfile) = @_;

    my (@info, @days, @depends);

    my $today = POSIX::strftime("%w", localtime(time));
    open CONF, $configfile or die "Cannot open $configfile for read :$!";

    while (<CONF>) {
	next if (/^\#/); # Comment
	next if (/^\s$/); # Whitespace

	@info = split /\t+/;

	# Only do this job if it is marked for doing today

	if ($info[1] =~ /$today/) {
	    # Dependencies
	    @depends = split /[,-]/, $info[2];
	    $jobs{$info[0]}->{'depends'} = [ @depends ];

	    # Log file
	    $jobs{$info[0]}->{'logfile'}=$info[3];

	    # Log days
	    $jobs{$info[0]}->{'log'}=$info[4];

	    # User
	    $jobs{$info[0]}->{'user'}=$info[5];

	    # Log days
	    $jobs{$info[0]}->{'machine'}=$info[6];

	    # Job command
	    $jobs{$info[0]}->{'command'}=$info[7];
	    chomp($jobs{$info[0]}->{'command'});

	    # Running?
	    $jobs{$info[0]}->{'pid'}=0;

	}
    }
}

#############################################################################

sub PrintJobs() {
    my $data;

    foreach (keys %jobs) {
	print "Job $_\n";

	print "Depends:";
	foreach $data (@{$jobs{$_}->{'depends'}}) {
	    print "$data,";
	}
	print "\nLog: ";
	print $jobs{$_}->{'log'};
	print "\nCommand: ";
	print $jobs{$_}->{'command'}."\n";
    }
}

#############################################################################
